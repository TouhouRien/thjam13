import "map.gr"
import "util.gr"

class Haniwa {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
    var targetSpeed: Vec2f;
    var speed: Vec2f;
    var offset: Vec2i;
    var direction: float;
    var isPlayer: bool;
    var onGround: bool;
}

export func initLevel() {
    var music = @Music("tinyClayBuddies");
    music.playTrack(2f);

    var tilemap = @Tilemap("level1");
    var map = initMap(tilemap, tilemap.width, tilemap.height);

    var scene = @Level.findSceneByName("level")?;
    updateMap(scene, map);

    initInput();

    var mayumi = initHaniwa(scene, map, "mayumi", @Vec2i(0, 8));
    updateHaniwa(mayumi);

    var seija = initHaniwa(scene, map, "seija", @Vec2i(1, 8));
    updateHaniwa(seija);
    updateSeija(scene, map, seija);

    var cirno = initHaniwa(scene, map, "cirno", @Vec2i(2, 8));
    updateHaniwa(cirno);
    updateCirno(scene, map, cirno);

    var saki = initHaniwa(scene, map, "saki", @Vec2i(3, 8));
    updateHaniwa(saki);
    updateSaki(scene, map, saki);

    var momoyo = initHaniwa(scene, map, "momoyo", @Vec2i(6, 3));
    updateHaniwa(momoyo);
    updateMomoyo(scene, map, momoyo);
}

func initInput() {
    @Input.addAction("up");
    @Input.addAction("down");
    @Input.addAction("left");
    @Input.addAction("right");
    @Input.addAction("jump");
    
    @Input.addActionEvent("up", @InputEvent.keyButton(KeyButton.up, KeyState.pressed));
    @Input.addActionEvent("down", @InputEvent.keyButton(KeyButton.down, KeyState.pressed));
    @Input.addActionEvent("left", @InputEvent.keyButton(KeyButton.left, KeyState.pressed));
    @Input.addActionEvent("right", @InputEvent.keyButton(KeyButton.right, KeyState.pressed));
    @Input.addActionEvent("jump", @InputEvent.keyButton(KeyButton.space, KeyState.pressed));
}

func initHaniwa(scene: Scene, map: Map, name: string, startPos: Vec2i)(Haniwa) {
    var offset = @Vec2i(0, 10);

    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos) - offset;
    actor.hitbox = @Vec2i(24, 32);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation(name);
    entity.addImage(animation);

    var haniwa = @Haniwa {
        entity = entity;
        animation = animation;
        actor = actor;
        targetSpeed = @Vec2f(5f, 5f);
        speed = @Vec2f.zero;
        offset = offset;
        direction = 1f;
    };

    return haniwa;
}

task updateHaniwa(haniwa: Haniwa) {
    loop yield {
        if (haniwa.isPlayer) {
            haniwa.speed.x = approach(haniwa.speed.x, @Input.getActionAxis("left", "right") * 3f, 0.5f);
        } else {
            haniwa.speed.x = approach(haniwa.speed.x, haniwa.targetSpeed.x, 0.5f);
        }

        haniwa.speed.y = approach(haniwa.speed.y, haniwa.targetSpeed.y, 0.5f);

        if (haniwa.onGround) {
            if (haniwa.isPlayer && @Input.isActionActivated("jump")) {
                haniwa.actor.dismount();
                haniwa.onGround = false;
                haniwa.targetSpeed.y = -10f;
            }
        }

        var collision = haniwa.actor.moveX(haniwa.speed.x);
        if (collision && haniwa.onGround) {
            haniwa.speed.x = 0f;
            haniwa.targetSpeed.x = -haniwa.targetSpeed.x;
            haniwa.animation.flipX = !haniwa.animation.flipX;
            haniwa.direction *= -1f;
        }

        var collision = haniwa.actor.moveY(haniwa.speed.y);
        if (collision) {
            var collision = collision?;

            if (collision.direction.y > 0) {
                haniwa.onGround = true;
                haniwa.actor.mount(collision.solid);
            }

            if (collision.direction.y < 0) {
                haniwa.targetSpeed.y = 0f;
            }
        } else {
            haniwa.onGround = false;
        }
    }
}

task updateCirno(scene: Scene, map: Map, haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (downRightId == TileType.water) {
            var freezeSFX = @Sound("freeze");
            freezeSFX.play();

            waterToIce(scene, map, downRightPos);
        }
    }
}

task updateSaki(scene: Scene, map: Map, haniwa: Haniwa) {
    var isJumping = false;

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (haniwa.onGround && !isJumping && !isSolid(downRightId)) {
            isJumping = true;
            var jumpSFX = @Sound("jump");
            jumpSFX.play();

            haniwa.targetSpeed.x = 0f;
            haniwa.targetSpeed.y = -10f;
        } else if (isJumping && isSolid(downRightId)) {
            isJumping = false;
            var rightPos = @Vec2i(tilePos.x + 1, tilePos.y);
            haniwa.targetSpeed.x = haniwa.direction;
            haniwa.targetSpeed.y = 5f;
        }
    }
}

task updateMomoyo(scene: Scene, map: Map, haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        if (haniwa.onGround) {
            if (belowId == TileType.rock) {
                var digSFX = @Sound("dig");
                digSFX.play();

                haniwa.targetSpeed.x = 0f;
                setMapId(belowPos.x, belowPos.y, TileType.air);
            } else if(isSolid(belowId)) {
                haniwa.targetSpeed.x = haniwa.direction;
            }
        }
    }
}

task updateSeija(scene: Scene, map: Map, haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var rightPos = @Vec2i(tilePos.x + 1, tilePos.y);
        var rightId = getMapId(rightPos.x, rightPos.y);

        if (haniwa.onGround) {
            if (rightId == TileType.down) {
                // @TODO sound

                var neighbors = getNeighbors(rightPos.x, rightPos.y, TileType.down);

                loop (cellId, neighbors.size) {
                    print("NEIGHBOR");

                    var cell = neighbors[cellId];
                    setMapId(rightPos.x, rightPos.y, TileType.up);
                }
            }
        }  
    }
}

func goal(scene: Scene, posX: int, posY: int) {
    var animation = @Animation("goal");

    var tileSize = animation.size as<Vec2i>;
    var halfSize = tileSize / 2;

    var startPosition = @Vec2i(posX * tileSize.x, (11 - posY) * tileSize.y);
    startPosition.x += halfSize.x;
    startPosition.y -= halfSize.y;

    var target = @Actor;
    target.position = startPosition;
    target.hitbox = halfSize;
    scene.addActor(target);

    var entity = @Entity;
    scene.addEntity(entity);
    target.entity = entity;

    entity.addImage(animation);
}