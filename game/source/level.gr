import "map.gr"
import "util.gr"

enum HaniwaType {
    mayumi;
    seija;
    cirno;
    saki;
    momoyo;
}

var haniwaTypeList: [string];
var haniwaTypeSpawned: [bool];
var spawnAreas: [Vec2i];
var haniwas: [Haniwa];

class Haniwa {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
    var baseSpeed: Vec2f;
    var targetSpeed: Vec2f;
    var speed: Vec2f;
    var offset: Vec2i;
    var direction: float;
    var isPlayer: bool;
    var onGround: bool;
    var isJumping: bool;
    var turnedOn: bool;
}

class Goal {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
}

export func initLevel() {
    @UI.clear();

    spawnAreas = default<[Vec2i]>;
    haniwaTypeList = default<[string]>;
    haniwaTypeSpawned = default<[bool]>;
    haniwas = default<[Haniwa]>;
    loop(i, HaniwaType.momoyo as<int> + 1) {
        haniwaTypeList ~= i as<HaniwaType> as<string>;
        haniwaTypeSpawned ~= false;
    }

    var music = @Music("tinyClayBuddies");
    music.playTrack(2f);

    var tilemap = @Tilemap("level1");
    var map = initMap(tilemap, tilemap.width, tilemap.height);

    var scene = @Level.findSceneByName("level")?;
    updateMap(scene, map);

    var goal = initGoal(scene, map, @Vec2i(15, 5));

    createDrawer(scene, map, goal);
}

func createDrawer(scene: Scene, map: Map, goal: Goal) {
    var width = 700f;
    var height = 100f;

    var drawer = @UIElement;
    drawer.size = @Vec2f(width, height);
    drawer.setAlign(UIAlignX.center, UIAlignY.bottom);
    drawer.position = @Vec2f(0f, 35f);

    var bg = @RoundedRectangle.fill(width, height, 8f);
    bg.anchor = @Vec2f.zero;
    bg.color = @Color(0.08f, 0.11f, 0.18f);
    drawer.addImage(bg);

    var hbox = @HBox;
    hbox.spacing = 16f;
    drawer.addUI(hbox);

    for(type, haniwaTypeList) {
        var btn = @UIElement;
        btn.size = @Vec2f(64, 64f);

        var rect = @RoundedRectangle.fill(btn.size.x, btn.size.y, 8f);
        rect.anchor = @Vec2f.zero;
        rect.color = @Color.red;
        btn.addImage(rect);

        var sprite = @Sprite(type);
        sprite.anchor = @Vec2f.half;
        sprite.position = @Vec2f(32f, 32f);

        btn.addImage(sprite);

        btn.addEventListener("click", event {
            switch(type)
            case("mayumi") {
                var mayumi = initHaniwa(scene, map, "mayumi", @Vec2i(0, 8), true);
                haniwas ~= mayumi;
                updateHaniwa(map, mayumi);
                updateJump(scene, map, mayumi);
                updateGoal(map, mayumi, goal);
            }
            case("seija") {
                var seija = initHaniwa(scene, map, "seija", @Vec2i(1, 8), false);
                haniwas ~= seija;
                updateHaniwa(map, seija);
                updateSeija(scene, map, seija);
            }
            case("cirno") {
                var cirno = initHaniwa(scene, map, "cirno", @Vec2i(2, 8), false);
                haniwas ~= cirno;
                updateHaniwa(map, cirno);
                updateCirno(scene, map, cirno);
            }
            case("saki") {
                var saki = initHaniwa(scene, map, "saki", @Vec2i(3, 8), false);
                haniwas ~= saki;
                updateHaniwa(map, saki);
                updateSaki(scene, map, saki);
            }
            case("momoyo") {
                var momoyo = initHaniwa(scene, map, "momoyo", @Vec2i(6, 3), false);
                haniwas ~= momoyo;
                updateHaniwa(map, momoyo);
                updateMomoyo(scene, map, momoyo);
            }
        });
        btn.addEventListener("mouseenter", event {
        rect.color = @Color.blue;
        });
        btn.addEventListener("mouseleave", event {
        rect.color = @Color.red;
        });
        hbox.addUI(btn);
    }

    @UI.add(drawer);
}

func initHaniwa(scene: Scene, map: Map, name: string, startPos: Vec2i, turnedOn: bool)(Haniwa) {
    var offset = @Vec2i(0, 10);

    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos) - offset;
    actor.hitbox = @Vec2i(24, 32);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation(name);
    entity.addImage(animation);

    var haniwa = @Haniwa {
        entity = entity;
        animation = animation;
        actor = actor;
        baseSpeed = @Vec2f(2f, 5f);
        targetSpeed = @Vec2f(2f, 5f);
        speed = @Vec2f.zero;
        offset = offset;
        direction = 1f;
        turnedOn = turnedOn;
    };

    return haniwa;
}

func resetSpeed(haniwa: Haniwa) {
    haniwa.targetSpeed.x = haniwa.direction * haniwa.baseSpeed.x;
    haniwa.targetSpeed.y = haniwa.baseSpeed.y;
}

func initGoal(scene: Scene, map: Map, startPos: Vec2i)(Goal) {
    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos);
    actor.hitbox = @Vec2i(24, 32);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation("goal");
    entity.addImage(animation);

    var goal = @Goal {
        entity = entity;
        animation = animation;
        actor = actor;
    };

    return goal;
}

task updateHaniwa(map: Map, haniwa: Haniwa) {
    loop yield {
        if (!haniwa.turnedOn) {
            haniwa.targetSpeed.x = 0f;
        } else {
            loop (otherId, haniwas.size) {
                var other = haniwas[otherId];
                if (other.turnedOn) {
                    continue;
                }

                var haniwaPos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
                var otherPos  = worldToMapPosition(map, other.actor.position + other.offset);

                if ((haniwaPos.x + 1 == otherPos.x || haniwaPos.x - 1 == otherPos.x) && haniwaPos.y == otherPos.y) {
                    var startSFX = @Sound("start");
                    startSFX.play();

                    other.turnedOn = true;
                    other.resetSpeed();
                }
            }
        }

        if (haniwa.isPlayer) {
            haniwa.speed.x = approach(haniwa.speed.x, @Input.getActionAxis("left", "right") * 3f, 0.5f);
        } else {
            haniwa.speed.x = approach(haniwa.speed.x, haniwa.targetSpeed.x, 0.5f);
        }

        haniwa.speed.y = approach(haniwa.speed.y, haniwa.targetSpeed.y, 0.5f);

        if (haniwa.onGround) {
            if (haniwa.isPlayer && @Input.isActionActivated("jump")) {
                haniwa.actor.dismount();
                haniwa.onGround = false;
                haniwa.targetSpeed.y = -10f;
            }
        }

        var collision = haniwa.actor.moveX(haniwa.speed.x);
        if (collision && haniwa.onGround) {
            haniwa.speed.x = 0f;
            haniwa.targetSpeed.x = -haniwa.targetSpeed.x;
            haniwa.animation.flipX = !haniwa.animation.flipX;
            haniwa.direction *= -1f;
        }

        var collision = haniwa.actor.moveY(haniwa.speed.y);
        if (collision) {
            var collision = collision?;

            if (collision.direction.y > 0) {
                haniwa.onGround = true;
                haniwa.actor.mount(collision.solid);
            }

            if (collision.direction.y < 0) {
                haniwa.onGround = false;
                haniwa.resetSpeed();
            }
        } else {
            haniwa.onGround = false;
        }
    }
}

task updateJump(scene: Scene, map: Map, haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);

        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (haniwa.onGround) {
            if (belowId == TileType.up && !haniwa.isJumping) {
                haniwa.isJumping = true;
                var jumpSFX = @Sound("jump");
                jumpSFX.play();

                haniwa.targetSpeed.x = 0f;
                haniwa.targetSpeed.y = -10f;
            }
        }
        else if (belowId != TileType.up && isSolid(downRightId)) {
            haniwa.isJumping = false;
            haniwa.resetSpeed();
        }
    }
}

task updateCirno(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (downRightId == TileType.water) {
            var freezeSFX = @Sound("freeze");
            freezeSFX.play();

            waterToIce(scene, map, downRightPos);
        }
    }
}

task updateSaki(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (haniwa.onGround && !haniwa.isJumping && !isSolid(downRightId)) {
            haniwa.isJumping = true;
            var jumpSFX = @Sound("jump");
            jumpSFX.play();

            haniwa.targetSpeed.x = 0f;
            haniwa.targetSpeed.y = -10f;
        } else if (isSolid(downRightId)) {
            haniwa.isJumping = false;
            haniwa.resetSpeed();
        }
    }
}

task updateMomoyo(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        if (haniwa.onGround) {
            if (belowId == TileType.rock) {
                var digSFX = @Sound("dig");
                digSFX.play();

                haniwa.targetSpeed.x = 0f;
                setMapId(belowPos.x, belowPos.y, TileType.air);
            } else if(belowId != TileType.up && isSolid(belowId)) {
                haniwa.resetSpeed();
            }
        }
    }
}

task updateSeija(scene: Scene, map: Map, haniwa: Haniwa) {
    var trigger = false;
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        if (haniwa.onGround && !haniwa.isJumping) {
            if (!trigger && belowId == TileType.down) {
                var flipSFX = @Sound("flip");
                flipSFX.play();
                setMapId(belowPos.x, belowPos.y, TileType.up);
                trigger = true;
            } else if (!trigger && belowId == TileType.up) {
                var flipSFX = @Sound("flip");
                flipSFX.play();
                setMapId(belowPos.x, belowPos.y, TileType.down);
                trigger = true;
            }
            
            if (belowId != TileType.down && belowId != TileType.up) {
                trigger = false;
            }
        }
    }
}

task updateGoal(map: Map, player: Haniwa, goal: Goal) {
    var won = false;

    loop yield {
        var playerPos = worldToMapPosition(map, player.actor.position + player.offset);
        var goalPos   = worldToMapPosition(map, goal.actor.position);

        if (!won && playerPos.x == goalPos.x && playerPos.y == goalPos.y) {
            var winSFX = @Sound("win");
            winSFX.play();
            won = true;
        }
    }
}