import "util.gr"

export func initLevel() {
    var scene = @Scene;
    scene.name = "level";

    @Level.addScene(scene);
    @Camera.setPosition(@App.center as<Vec2f>);

    var tilemap = @Tilemap("level2");
    tilemap.anchor = @Vec2f.zero;

    var map = @Entity;
    map.addImage(tilemap);
    scene.addEntity(map);

    var width = tilemap.width;
    var height = tilemap.height;

    loop (y, height) {
        loop (x, width) {
            var tileId = tilemap.getTile(x, y);

            if (isSolid(tileId)) {
                var solid = addSolid(scene, tilemap, @Vec2i(x, y), tileId);

                var nextTileId = tilemap.getTile(x + 1, y);
                if (!isSolid(nextTileId)) {
                    solid.addTag("stop");
                }

                var belowTileId = tilemap.getTile(x - 1, y - 1);
                var startTileId = tilemap.getTile(x - 1, y - 2);
                if (!isSolid(belowTileId) && !isSolid(startTileId)) {
                    var startTile = addSolid(scene, tilemap, @Vec2i(x - 1, y - 2), tileId);
                    startTile.addTag("start");
                }
            }
        }
    }

    haniwa(scene, tilemap, "mayumi", 0, 0, true);
    haniwa(scene, tilemap, "seija", 1, 0, false);
    haniwa(scene, tilemap, "cirno", 2, 0, false);
    haniwa(scene, tilemap, "saki", 3, 0, false);
    haniwa(scene, tilemap, "momoyo", 10, 11, false);
}

func addSolid(scene: Scene, tilemap: Tilemap, tilePos: Vec2i, tileId: int)(Solid) {
    var tileSize = tilemap.tileSize;

    var solid = @Solid;
    solid.position = @Vec2i(tilePos.x * tileSize.x as<int>, tilePos.y * tileSize.y as<int>) + @Vec2i(16, 16);
    solid.hitbox = @Vec2i(16, 16);
    solid.addTag(tileToName(tileId));
    scene.addSolid(solid);

    return solid;
}

func isSolid(tileId: int)(bool) {
    return tileId > 1;
}

func tileToName(tileId: int)(string) {
    switch(tileId)
    case(0)
        return "air";
    case(1)
        return "water";
    case(2)
        return "earth";
    case(3)
        return "rock";
    case(4)
        return "ice";
    case(6)
        return "obstacle";

    return "";
}

func nameToTileId(name: string)(int) {
    switch(name)
    case("air")
        return 0;
    case("water")
        return 1;
    case("earth")
        return 2;
    case("rock")
        return 3;
    case("ice")
        return 4;
    case("obstacle")
        return 6;

    return -1;
}

func tilePositionWorldToTilemap(tilemap: Tilemap, vec: Vec2i)(Vec2i) {
    var noOffset = @Vec2i(vec.x - 16, vec.y - 16);
    var noSize   = @Vec2i(noOffset.x / 32, noOffset.y / 32);
    return noSize;
}

func waterToIce(scene: Scene, tilemap: Tilemap, tilePos: Vec2i, tileId: int) {
    var isWater = false;
    var nextPos = @Vec2i(tilePos.x + 1, tilePos.y);

    do {
        var nextId = getTile(tilemap, nextPos.x, nextPos.y);

        if (tileToName(nextId) == "water") {
            var iceId = nameToTileId("ice");
            setTile(tilemap, nextPos.x, nextPos.y, iceId);
            addSolid(scene, tilemap, nextPos, iceId);
            isWater = true;
        } else {
            isWater = false;
        }

        nextPos = @Vec2i(nextPos.x + 1, nextPos.y);
    } while (isWater);
}

func initInput() {
    @Input.addAction("up");
    @Input.addAction("down");
    @Input.addAction("left");
    @Input.addAction("right");
    @Input.addAction("jump");
    @Input.addAction("restart");
    
    @Input.addActionEvent("up", @InputEvent.keyButton(KeyButton.up, KeyState.pressed));
    @Input.addActionEvent("down", @InputEvent.keyButton(KeyButton.down, KeyState.pressed));
    @Input.addActionEvent("left", @InputEvent.keyButton(KeyButton.left, KeyState.pressed));
    @Input.addActionEvent("right", @InputEvent.keyButton(KeyButton.right, KeyState.pressed));
    @Input.addActionEvent("jump", @InputEvent.keyButton(KeyButton.space, KeyState.pressed));
    @Input.addActionEvent("restart", @InputEvent.keyButton(KeyButton.r, KeyState.pressed));
}

task haniwa(scene: Scene, tilemap: Tilemap, name: string, posX: int, posY: int, isPlayer: bool) {
    initInput();

    var scene = @Level.findSceneByName("level")?;

    var startPosition = @Vec2i(posX * 32, (23 - posY) * 32);
    startPosition.x += 16;
    startPosition.y -= 16;

    var player = @Actor;
    player.position = startPosition;
    player.hitbox = @Vec2i(12, 12);
    scene.addActor(player);

    var entity = @Entity;
    scene.addEntity(entity);
    player.entity = entity;

    var sprite = @Sprite(name);
    sprite.position = @Vec2f(0, -4);
    entity.addImage(sprite);

    var targetSpeedX = 1f;
    var targetSpeedY = 5f;

    var speedX: float;
    var speedY: float;
    var isOnGround: bool;

    loop yield {
        if (isPlayer) {
            speedX = approach(speedX, @Input.getActionAxis("left", "right") * 3f, 0.5f);
        } else {
            speedX = approach(speedX, targetSpeedX, 0.5f);
        }

        speedY = approach(speedY, targetSpeedY, 0.5f);

        if (@Input.isActionActivated("restart")) {
            player.position = startPosition;
        }

        if (isOnGround) {
            if (isPlayer && @Input.isActionActivated("jump")) {
                player.dismount();
                isOnGround = false;
                targetSpeedY = -10f;
            }
        }

        var collision = player.moveX(speedX);
        if (collision) {
            if (name == "seija" && block.hasTag("obstacle")) {
                // Retourner obstacle
            }
        }

        var collision = player.moveY(speedY);
        if (collision) {
            var collision = collision?;
            var block     = collision.solid;

            if (collision.direction.y > 0) {
                isOnGround = true;
                player.mount(collision.solid);

                // Recupere l'id du block
                var tilePos = tilePositionWorldToTilemap(tilemap, block.position);
                var tileId  = getTile(tilemap, tilePos.x, tilePos.y);

                if (name == "momoyo" && block.hasTag("rock")) {
                    targetSpeedX = 0f;
                    setTile(tilemap, tilePos.x, tilePos.y, nameToTileId("air"));
                    block.remove();
                }

                // Saki saute en rencontrant du vide
                if (name == "saki") {
                    if (block.hasTag("stop")) {
                        targetSpeedX = 0f;
                        targetSpeedY = -10f;
                    } else {
                        targetSpeedY = 5f;
                    }
                }

                // Cirno s'arrete en rencontrant du vide et transforme le prochain bloc en glace si c'est de l'eau
                if (name == "cirno" && block.hasTag("stop")) {
                    targetSpeedX = 0f;
                    waterToIce(scene, tilemap, tilePos, tileId);
                }
            } else {
                // Saki apres un saut trouve la prochaine plateforme
                if (name == "saki" && block.hasTag("start")) {
                    targetSpeedY = 0.4f;
                    targetSpeedX = 1f;
                }
            }

            if (collision.direction.y < 0) {
                speedY = 0f;
            }
        } else {
            isOnGround = false;
        }
    }
}

task flip() {
    
}