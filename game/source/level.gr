import "map.gr"
import "util.gr"

class Haniwa {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
    var baseSpeed: Vec2f;
    var targetSpeed: Vec2f;
    var speed: Vec2f;
    var offset: Vec2i;
    var direction: float;
    var isPlayer: bool;
    var onGround: bool;
    var isJumping: bool;
    var turnedOn: bool;
}

class Goal {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
}

export func initLevel() {
    var music = @Music("tinyClayBuddies");
    music.playTrack(2f);

    var tilemap = @Tilemap("level1");
    var map = initMap(tilemap, tilemap.width, tilemap.height);

    var scene = @Level.findSceneByName("level")?;
    updateMap(scene, map);

    initInput();

    var mayumi = initHaniwa(scene, map, "mayumi", @Vec2i(0, 8), true);
    var seija = initHaniwa(scene, map, "seija", @Vec2i(1, 8), false);
    var cirno = initHaniwa(scene, map, "cirno", @Vec2i(2, 8), false);
    var saki = initHaniwa(scene, map, "saki", @Vec2i(3, 8), false);
    var momoyo = initHaniwa(scene, map, "momoyo", @Vec2i(6, 3), false);

    var haniwas = [
        mayumi, seija, cirno, saki, momoyo
    ];

    updateHaniwa(map, mayumi, haniwas);
    updateJump(scene, map, mayumi);

    updateHaniwa(map, seija, haniwas);
    updateSeija(scene, map, seija);

    updateHaniwa(map, cirno, haniwas);
    updateCirno(scene, map, cirno);

    updateHaniwa(map, saki, haniwas);
    updateSaki(scene, map, saki);

    updateHaniwa(map, momoyo, haniwas);
    updateMomoyo(scene, map, momoyo);

    var goal = initGoal(scene, map, @Vec2i(15, 5));
    updateGoal(map, mayumi, goal);
}

func initInput() {
    @Input.addAction("up");
    @Input.addAction("down");
    @Input.addAction("left");
    @Input.addAction("right");
    @Input.addAction("jump");
    
    @Input.addActionEvent("up", @InputEvent.keyButton(KeyButton.up, KeyState.pressed));
    @Input.addActionEvent("down", @InputEvent.keyButton(KeyButton.down, KeyState.pressed));
    @Input.addActionEvent("left", @InputEvent.keyButton(KeyButton.left, KeyState.pressed));
    @Input.addActionEvent("right", @InputEvent.keyButton(KeyButton.right, KeyState.pressed));
    @Input.addActionEvent("jump", @InputEvent.keyButton(KeyButton.space, KeyState.pressed));
}

func initHaniwa(scene: Scene, map: Map, name: string, startPos: Vec2i, turnedOn: bool)(Haniwa) {
    var offset = @Vec2i(0, 10);

    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos) - offset;
    actor.hitbox = @Vec2i(24, 32);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation(name);
    entity.addImage(animation);

    var haniwa = @Haniwa {
        entity = entity;
        animation = animation;
        actor = actor;
        baseSpeed = @Vec2f(2f, 5f);
        targetSpeed = @Vec2f(2f, 5f);
        speed = @Vec2f.zero;
        offset = offset;
        direction = 1f;
        turnedOn = turnedOn;
    };

    return haniwa;
}

func resetSpeed(haniwa: Haniwa) {
    haniwa.targetSpeed.x = haniwa.direction * haniwa.baseSpeed.x;
    haniwa.targetSpeed.y = haniwa.baseSpeed.y;
}

func initGoal(scene: Scene, map: Map, startPos: Vec2i)(Goal) {
    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos);
    actor.hitbox = @Vec2i(24, 32);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation("goal");
    entity.addImage(animation);

    var goal = @Goal {
        entity = entity;
        animation = animation;
        actor = actor;
    };

    return goal;
}

task updateHaniwa(map: Map, haniwa: Haniwa, others: [Haniwa]) {
    loop yield {
        if (!haniwa.turnedOn) {
            haniwa.targetSpeed.x = 0f;
        } else {
            loop (otherId, others.size) {
                var other = others[otherId];
                if (other.turnedOn) {
                    continue;
                }

                var haniwaPos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
                var otherPos  = worldToMapPosition(map, other.actor.position + other.offset);

                if ((haniwaPos.x + 1 == otherPos.x || haniwaPos.x - 1 == otherPos.x) && haniwaPos.y == otherPos.y) {
                    // @TODO sound
                    other.turnedOn = true;
                    other.resetSpeed();
                }
            }
        }

        if (haniwa.isPlayer) {
            haniwa.speed.x = approach(haniwa.speed.x, @Input.getActionAxis("left", "right") * 3f, 0.5f);
        } else {
            haniwa.speed.x = approach(haniwa.speed.x, haniwa.targetSpeed.x, 0.5f);
        }

        haniwa.speed.y = approach(haniwa.speed.y, haniwa.targetSpeed.y, 0.5f);

        if (haniwa.onGround) {
            if (haniwa.isPlayer && @Input.isActionActivated("jump")) {
                haniwa.actor.dismount();
                haniwa.onGround = false;
                haniwa.targetSpeed.y = -10f;
            }
        }

        var collision = haniwa.actor.moveX(haniwa.speed.x);
        if (collision && haniwa.onGround) {
            haniwa.speed.x = 0f;
            haniwa.targetSpeed.x = -haniwa.targetSpeed.x;
            haniwa.animation.flipX = !haniwa.animation.flipX;
            haniwa.direction *= -1f;
        }

        var collision = haniwa.actor.moveY(haniwa.speed.y);
        if (collision) {
            var collision = collision?;

            if (collision.direction.y > 0) {
                haniwa.onGround = true;
                haniwa.actor.mount(collision.solid);
            }

            if (collision.direction.y < 0) {
                haniwa.onGround = false;
                haniwa.resetSpeed();
            }
        } else {
            haniwa.onGround = false;
        }
    }
}

task updateJump(scene: Scene, map: Map, haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);

        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (haniwa.onGround) {
            if (belowId == TileType.up && !haniwa.isJumping) {
                haniwa.isJumping = true;
                var jumpSFX = @Sound("jump");
                jumpSFX.play();

                haniwa.targetSpeed.x = 0f;
                haniwa.targetSpeed.y = -10f;
            }
        }
        // @TODO fix stop jumping
        else if (belowId == TileType.air && isSolid(downRightId)) {
            haniwa.isJumping = false;
            haniwa.resetSpeed();
        }
    }
}

task updateCirno(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (downRightId == TileType.water) {
            var freezeSFX = @Sound("freeze");
            freezeSFX.play();

            waterToIce(scene, map, downRightPos);
        }
    }
}

task updateSaki(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var downRightPos = @Vec2i(tilePos.x + 1, tilePos.y + 1);
        var downRightId = getMapId(downRightPos.x, downRightPos.y);

        if (haniwa.onGround && !haniwa.isJumping && !isSolid(downRightId)) {
            haniwa.isJumping = true;
            var jumpSFX = @Sound("jump");
            jumpSFX.play();

            haniwa.targetSpeed.x = 0f;
            haniwa.targetSpeed.y = -10f;
        } else if (isSolid(downRightId)) {
            haniwa.isJumping = false;
            haniwa.resetSpeed();
        }
    }
}

task updateMomoyo(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        if (haniwa.onGround) {
            if (belowId == TileType.rock) {
                var digSFX = @Sound("dig");
                digSFX.play();

                haniwa.targetSpeed.x = 0f;
                setMapId(belowPos.x, belowPos.y, TileType.air);
            } else if(isSolid(belowId)) {
                haniwa.resetSpeed();
            }
        }
    }
}

task updateSeija(scene: Scene, map: Map, haniwa: Haniwa) {
    updateJump(scene, map, haniwa);

    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position + haniwa.offset);
        var belowPos = @Vec2i(tilePos.x, tilePos.y + 1);
        var belowId = getMapId(belowPos.x, belowPos.y);

        if (haniwa.onGround && !haniwa.isJumping) {
            if (belowId == TileType.down) {
                // @TODO sound
                setMapId(belowPos.x, belowPos.y, TileType.up);
            } else if (belowId == TileType.up) {
                // @TODO sound
                setMapId(belowPos.x, belowPos.y, TileType.down);
            }
        }
    }
}

task updateGoal(map: Map, player: Haniwa, goal: Goal) {
    loop yield {
        var playerPos = worldToMapPosition(map, player.actor.position + player.offset);
        var goalPos   = worldToMapPosition(map, goal.actor.position);

        if (playerPos.x == goalPos.x && playerPos.y == goalPos.y) {
            print("WIN!");
        }
    }
}