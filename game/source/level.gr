import "map.gr"
import "solid.gr"
import "util.gr"

class Haniwa {
    var entity: Entity;
    var animation: Animation;
    var actor: Actor;
    var targetSpeed: Vec2f;
    var speed: Vec2f;
    var isPlayer: bool;
    var onGround: bool;
}

func initHaniwa(scene: Scene, map: Map, name: string, startPos: Vec2i)(Haniwa) {
    var actor = @Actor;
    actor.position = mapToWorldPosition(map, startPos);
    scene.addActor(actor);

    var entity = @Entity;
    scene.addEntity(entity);
    actor.entity = entity;

    var animation = @Animation(name);
    actor.hitbox = animation.size as<Vec2i> / 2;
    entity.addImage(animation);

    var haniwa = @Haniwa {
        entity = entity;
        animation = animation;
        actor = actor;
        targetSpeed = @Vec2f(1f, 5f);
        speed = @Vec2f.zero;
    };

    return haniwa;
}

export func initLevel() {
    var music = @Music("tinyClayBuddies");
    music.playTrack(2f);

    var freezeSFX = @Sound("freeze");
    freezeSFX.play();

    var tilemap = @Tilemap("level1");
    var map = initMap(tilemap, tilemap.width, tilemap.height);

    var scene = @Level.findSceneByName("level")?;
    updateMap(scene, map);

    initInput();

    var mayumi = initHaniwa(scene, map, "mayumi", @Vec2i(0, 9));
    updateHaniwa(mayumi);
    var seija = initHaniwa(scene, map, "seija", @Vec2i(1, 9));
    updateHaniwa(seija);
    var cirno = initHaniwa(scene, map, "cirno", @Vec2i(2, 9));
    updateHaniwa(cirno);
    var saki = initHaniwa(scene, map, "saki", @Vec2i(3, 9));
    updateHaniwa(saki);
}

func initInput() {
    @Input.addAction("up");
    @Input.addAction("down");
    @Input.addAction("left");
    @Input.addAction("right");
    @Input.addAction("jump");
    
    @Input.addActionEvent("up", @InputEvent.keyButton(KeyButton.up, KeyState.pressed));
    @Input.addActionEvent("down", @InputEvent.keyButton(KeyButton.down, KeyState.pressed));
    @Input.addActionEvent("left", @InputEvent.keyButton(KeyButton.left, KeyState.pressed));
    @Input.addActionEvent("right", @InputEvent.keyButton(KeyButton.right, KeyState.pressed));
    @Input.addActionEvent("jump", @InputEvent.keyButton(KeyButton.space, KeyState.pressed));
}

task updateHaniwa(haniwa: Haniwa) {
    loop yield {
        if (haniwa.isPlayer) {
            haniwa.speed.x = approach(haniwa.speed.x, @Input.getActionAxis("left", "right") * 3f, 0.5f);
        } else {
            haniwa.speed.x = approach(haniwa.speed.x, haniwa.targetSpeed.x, 0.5f);
        }

        haniwa.speed.y = approach(haniwa.speed.y, haniwa.targetSpeed.y, 0.5f);

        if (haniwa.onGround) {
            if (haniwa.isPlayer && @Input.isActionActivated("jump")) {
                haniwa.actor.dismount();
                haniwa.onGround = false;
                haniwa.targetSpeed.y = -10f;
            }
        }

        var collision = haniwa.actor.moveX(haniwa.speed.x);
        if (collision) {
        }

        var collision = haniwa.actor.moveY(haniwa.speed.y);
        if (collision) {
            var collision = collision?;

            if (collision.direction.y > 0) {
                haniwa.onGround = true;
                haniwa.actor.mount(collision.solid);
            }

            if (collision.direction.y < 0) {
                haniwa.targetSpeed.y = 0f;
            }
        } else {
            haniwa.onGround = false;
        }
    }
}

task updateCirno(haniwa: Haniwa) {
    loop yield {
        var tilePos = worldToMapPosition(map, haniwa.actor.position);
    }
}

func goal(scene: Scene, posX: int, posY: int) {
    var animation = @Animation("goal");

    var tileSize = animation.size as<Vec2i>;
    var halfSize = tileSize / 2;

    var startPosition = @Vec2i(posX * tileSize.x, (11 - posY) * tileSize.y);
    startPosition.x += halfSize.x;
    startPosition.y -= halfSize.y;

    var target = @Actor;
    target.position = startPosition;
    target.hitbox = halfSize;
    scene.addActor(target);

    var entity = @Entity;
    scene.addEntity(entity);
    target.entity = entity;

    entity.addImage(animation);
}