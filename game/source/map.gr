import "solid.gr"

export enum TileName {
    air;
    water;
    earth;
    rock;
    ice;
}

class Cell {
    var id: int;
    var solid: Solid?;
}

export class Map {
    var grid: [[Cell]];
    var width: uint;
    var height: uint;
    var entity: Entity;
    var tilemap: Tilemap;
    var tileSize: Vec2i;
    var halfSize: Vec2i;
}

var currentMap: Map?;

export func initMap(width : uint, height: uint)(Map) {
    var tileset = @Tileset("terrain");
    var tilemap = @Tilemap(tileset, width, height);
    return initMap(tilemap, width, height);
}

export func initMap(tilemap: Tilemap, width: uint, height: uint)(Map) {
    var map = @Map {
        width = width;
        height = height;
        tilemap = tilemap;
        tileSize = tilemap.tileSize as<Vec2i>;
        halfSize = tilemap.tileSize as<Vec2i> / 2;
    };
    map.tilemap.anchor = @Vec2f.zero;

    loop(x, width) {
        var column: [Cell];

        loop(y, height) {
            column ~= @Cell {
                id = tilemap.getTile(x, y);
            };
        }

        map.grid ~= column;
    }

    var scene = @Scene;
    scene.name = "level";

    @Level.addScene(scene);
    @Camera.setPosition(@App.center as<Vec2f>);

    var gamebg = @Sprite("gamebg");
    gamebg.anchor = @Vec2f.zero;

    map.entity.addImage(gamebg);
    map.entity.addImage(map.tilemap);
    scene.addEntity(map.entity);

    currentMap = map;
    return map;
}

export func isSolid(cell: Cell)(bool) {
    return cell.id > 1;
}

export task updateMap(scene: Scene, map: Map) {
    loop yield {
        if(@Input.isDown(KeyButton.f1))
            scene.showColliders = !scene.showColliders;

        loop (x, map.width) {
            loop (y, map.height) {
                var cell = map.grid[x][y];

                if (isSolid(cell) && !cell.solid) {
                    var worldPos = mapToWorldPosition(map, @Vec2i(x, y));
                    cell.solid = addSolid(scene, worldPos, map.halfSize, cell.id);
                }

                /*if (!isSolid(cell) && cell.solid) {
                    var solid = cell.solid?;
                    solid.remove();
                    cell.solid = null;
                }*/
            }
        }
    }
}

export func worldToMapPosition(map: Map, vec: Vec2i)(Vec2i) {
    var noOffset = @Vec2i(vec.x - map.halfSize.x, vec.y - map.halfSize.y);
    var noSize   = @Vec2i(noOffset.x / map.tileSize.x, noOffset.y / map.tileSize.y);
    return noSize;
}

export func mapToWorldPosition(map: Map, mapPos: Vec2i)(Vec2i) {
    var worldPos = @Vec2i(mapPos.x * map.tileSize.x, mapPos.y * map.tileSize.y);

    worldPos.x += map.halfSize.x;
    worldPos.y += map.halfSize.y;

    return worldPos;
}

export func setMapId(x: uint, y: uint, id: int) {
    var map = currentMap?;
    if(x >= map.width or y >= map.height)
        return;
    map.grid[x][y].id = id;
    map.tilemap.setTile(x, y, id);
}

export func getMapId(x: uint, y: uint) (int) {
    var map = currentMap?;
    if(x >= map.width or y >= map.height)
        return;
    return map.grid[x][y].id;
}